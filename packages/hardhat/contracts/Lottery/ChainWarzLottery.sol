// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./BlackListManager.sol";

/// @title Chainwarz Lottery
/// @notice It consumes VRF v1 from Chainlink. It has the role
/// "operator" that is the one used by a backend app to make some calls
/// @dev It saves in an ordered array the player wallet and the current
/// entries count. So buying entries has a complexity of O(1)
/// For calculating the winner, from the huge random number generated by Chainlink
/// a normalized random is generated by using the module method, adding 1 to have
/// a random from 1 to entriesCount.
/// So next step is to perform a binary search on the ordered array to get the
/// player O(log n)
/// Example:
/// 0 -> { 1, player1} as player1 buys 1 entry
/// 1 -> {51, player2} as player2 buys 50 entries
/// 2 -> {52, player3} as player3 buys 1 entry
/// 3 -> {53, player4} as player4 buys 1 entry
/// 4 -> {153, player5} as player5 buys 100 entries
/// So the setWinner method performs a binary search on that sorted array to get the upper bound.
/// If the random number generated is 150, the winner is player5. If the random number is 20, winner is player2
contract ChainWarzLottery is ReentrancyGuard, VRFConsumerBase, Ownable {
    ////////// CHAINLINK VRF v1 /////////////////
    bytes32 internal keyHash; // chainlink
    uint256 internal fee; // fee paid in LINK to chainlink. 0.1 on testnet, 2 on mainnet

    address payable public treasuryWallet;
    address public operatorAddress;
    address public injectorAddress;

    address payable public stakersAddress;

    // contract that contains the black list
    BlackListManager blackListManager;

    uint256 public constant MAX_TREASURY_FEE = 1000; // 10%
    uint256 public constant MAX_JACKPOT_BATTLE_CONTRIBUTION = 1000; // 10%

    uint256 public stakersReward = 1000; // 10%

    struct BattleInfo {
        uint256 id; // battleId
        uint256 size; // length of the entries array of that battle
    }

    // map the requestId created by chainlink with the battle info passed as param when calling getRandomNumber()
    mapping(bytes32 => BattleInfo) public chainlinkBattleInfo;

    /////////////// END CHAINKINK VRF V1 //////////////

    /* every battle has an array of price structure (max size = 5) with the different 
    prices for the different entries bought. The price for 1 entry is different than 
    for 5 entries where there is a discount*/
    struct PriceStructure {
        uint256 id;
        uint256 numEntries;
        uint256 price;
    }
    mapping(uint256 => PriceStructure[5]) public prices;

    // In order to calculate the winner, in this struct is saved for each bought the data
    struct EntriesBought {
        uint256 currentEntriesLength; // current amount of entries bought in the battle
        address player; // wallet address of the player
    }

    // every battle has a sorted array of EntriesBought. Each element is created when calling
    // either buyFighter or giveBatchEntriesForFree
    mapping(uint256 => EntriesBought[]) public entriesList;

    // Main battle data struct
    struct BattleStruct {
        Status status; // status of the battle. Can be created, accepted, ended, etc
        uint256 maxEntries; // maximum number of entries allowed per user, to avoid abuse
        address winner; // address of thed winner of the battle. Address(0) if no winner yet
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        uint256 amountCollected; // funds raised so far in wei
        uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%
        uint256 weeklyJackpotBattle;
        uint256 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint256 cancellingDate;
        address[] nftCollectionWhitelist; // addresses of the required nfts. Will be empty if no NFT is required to buy
    }

    BattleStruct[] public battles;

    // Map that contains the number of entries each user has bought, to prevent abuse, and the claiming info
    struct ClaimStruct {
        uint256 numEntriesPerUser;
        uint256 amountSpentInWeis;
        bool claimed;
    }
    mapping(bytes32 => ClaimStruct) public claimsData;

    // Map with the addresses linked to a particular battle + nft
    mapping(bytes32 => address) public requiredNFTWallets;

    enum Status {
        Pending,
        Open,
        Close,
        Cancelled
    }

    modifier notContract() {
        require(!_isContract(msg.sender), "Contract not allowed");
        _;
    }

    modifier onlyOperator() {
        require(msg.sender == operatorAddress, "Not operator");
        _;
    }

    modifier onlyOwnerOrInjector() {
        require((msg.sender == owner()) || (msg.sender == injectorAddress), "Not owner or injector");
        _;
    }

    event BattleStarted(uint256 indexed battleId);
    event BattleEnd(uint256 indexed battleId, uint256 amountCollected);
    event FightersPurchase(
        uint256 indexed battleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId
    );
    event FreeEntry(uint256 indexed battleId, address[] buyer, uint256 amount, uint256 currentSize);
    event BattleCancelled(uint256 indexed battleId, uint256 amountCollected);
    event PrizeTransferred(
        uint256 indexed battleId,
        uint256 treasuryFee,
        uint256 weeklyJackpotBattle,
        uint256 stakersReward,
        uint256 indexed winnerPrize
    );
    event RemainingFundsTransferred(uint256 indexed battleId, uint256 amountInWeis);
    event Refund(uint256 indexed battleId, uint256 amountInWeis, address indexed player);
    event EntryCancelled(uint256 indexed battleId, uint256 amountOfEntriesCanceled, address player);
    event RandomNumberCreated(uint256 indexed idFromMetawin, uint256 randomNumber, uint256 normalizedRandomNumber);
    event BattleInjection(uint256 indexed battleId, uint256 injectedAmount);
    event StakersRewardChanged(uint256 indexed newStakersReward);

    constructor(
        address _blacklistManager,
        address _vrfCoordinator,
        address _linkToken,
        address _treasuryWallet,
        address _operatorAddress,
        address _injectorAddress,
        bytes32 _keyHash,
        bool _mainnetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        operatorAddress = _operatorAddress;
        injectorAddress = _injectorAddress;
        keyHash = _keyHash;
        if (_mainnetFee == true)
            fee = 2 * 10 ** 18; // on mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK on Goerli

        blackListManager = BlackListManager(_blacklistManager);
        treasuryWallet = payable(_treasuryWallet);
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// Also it is checked the maximum number of entries per user is not reached
    /// As the method is payable, in msg.value there will be the amount paid by the user
    /// @notice If the operator set requiredNFTs when creating the battle, only the owners of nft on that collection can make a call to this method. This will be
    /// used for special battles
    /// @param _battleId: id of the battle
    /// @param _priceId: id of the price structure
    /// @param _collection: collection of the tokenId used. Not used if there is no required nft on the battle
    /// @param _tokenIdUsed: id of the token used in private battles (to avoid abuse can not be reused on the same battle)
    function buyFighter(
        uint256 _battleId,
        uint256 _priceId,
        address _collection,
        uint256 _tokenIdUsed
    ) external payable nonReentrant notContract {
        BattleStruct storage battle = battles[_battleId];

        require(blackListManager.isBlackListed(msg.sender) == false, "Blacklisted!");

        // * If the battle requires an nft
        if (battle.nftCollectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i = 0; i < battle.nftCollectionWhitelist.length; i++) {
                if (battle.nftCollectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            require(hasRequiredCollection == true, "Not in required collection");
            IERC721 requiredNFT = IERC721(_collection);
            require(requiredNFT.ownerOf(_tokenIdUsed) == msg.sender, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(abi.encode(_collection, _battleId, _tokenIdUsed));
            // check the tokenId has not been using yet in the battle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] == address(0)) {
                requiredNFTWallets[hashRequiredNFT] = msg.sender;
            } else require(requiredNFTWallets[hashRequiredNFT] == msg.sender, "tokenId used");
        }

        require(msg.sender != address(0), "msg.sender is null"); // 37
        require(_priceId > 0, "howMany is 0");
        require(battle.status == Status.Open, "Battle is not open"); // 1808
        PriceStructure memory priceStruct = getPriceStructForId(_battleId, _priceId);
        require(priceStruct.numEntries > 0, "numEntries not supported");
        require(msg.value == priceStruct.price, "msg.value must be equal to the price"); // 1722

        bytes32 hash = keccak256(abi.encode(msg.sender, _battleId));
        // check there are enough entries left for this particular user
        if (battle.maxEntries > 0) {
            require(
                claimsData[hash].numEntriesPerUser + priceStruct.numEntries <= battle.maxEntries,
                "Bought too many entries"
            );
        }

        EntriesBought memory entryBought = EntriesBought({
            player: msg.sender,
            currentEntriesLength: battle.entriesLength + priceStruct.numEntries
        });
        entriesList[_battleId].push(entryBought);

        battle.amountCollected += msg.value; // 6917 gas
        // update the field entriesLength, used in frontend to avoid making extra calls
        battle.entriesLength = battle.entriesLength + priceStruct.numEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += priceStruct.numEntries;
        claimsData[hash].amountSpentInWeis += msg.value;

        emit FightersPurchase(_battleId, msg.sender, battle.entriesLength, _priceId); // 2377
    }

    // The operator can add free entries to the battle
    /// @param _battleId Id of the battle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        uint256 _battleId,
        address[] memory _freePlayers
    ) external nonReentrant onlyOperator {
        require(battles[_battleId].status == Status.Open, "Battle is not in accepted");

        uint256 freePlayersLength = _freePlayers.length;
        uint256 validPlayersCount = 0;
        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];

             if (
                battles[_battleId].maxEntries == 0 
            ) {
                // add a new element to the entriesBought array.
                // as this method only adds 1 entry per call, the amountbought is always 1
                EntriesBought memory entryBought = EntriesBought({
                    player: entry,
                    currentEntriesLength: battles[_battleId].entriesLength + i + 1
                });
                entriesList[_battleId].push(entryBought);

                claimsData[keccak256(abi.encode(entry, _battleId))].numEntriesPerUser++;

                ++validPlayersCount;
            } else if (
                battles[_battleId].maxEntries > 0 &&
                claimsData[keccak256(abi.encode(entry, _battleId))].numEntriesPerUser + 1 <=
                battles[_battleId].maxEntries
            ) {

                EntriesBought memory entryBought = EntriesBought({
                    player: entry,
                    currentEntriesLength: battles[_battleId].entriesLength + i + 1
                });
                entriesList[_battleId].push(entryBought);

                claimsData[keccak256(abi.encode(entry, _battleId))].numEntriesPerUser++;

                ++validPlayersCount;
            }
        }

        battles[_battleId].entriesLength = battles[_battleId].entriesLength + validPlayersCount;

        emit FreeEntry(_battleId, _freePlayers, freePlayersLength, battles[_battleId].entriesLength);
    }


    /// @param _maxEntriesPerUser To avoid whales, the number of entries an user can have is limited
    /// @param _prices Array of prices and amount of entries the customer could purchase
    /// @param _treasuryFeeInBps commission for the platform, in basic points
    /// @param _nftCollectionWhitelist array with the required collections to participate in the battle. Empty if there is no collection
    /// @notice Creates a battle
    /// @dev creates a battle struct and push it to the battles array. Some data is stored in the funding data structure
    /// sends an event when finished
    /// @return battleId
    function startBattle(
        uint256 _maxEntriesPerUser,
        PriceStructure[] calldata _prices,
        uint256 _treasuryFeeInBps,
        uint256 _weeklyJackpotBattleInBps,
        address[] calldata _nftCollectionWhitelist
    ) external onlyOperator returns (uint256) {
        require(_treasuryFeeInBps <= MAX_TREASURY_FEE, "treasury fee too high");
        require(_weeklyJackpotBattleInBps <= MAX_JACKPOT_BATTLE_CONTRIBUTION, "WB contribution too high");

        BattleStruct memory battle = BattleStruct({
            status: Status.Open,
            maxEntries: _maxEntriesPerUser,
            winner: address(0),
            randomNumber: 0,
            amountCollected: 0,
            treasuryFee: _treasuryFeeInBps,
            weeklyJackpotBattle: _weeklyJackpotBattleInBps,
            entriesLength: 0,
            cancellingDate: 0,
            nftCollectionWhitelist: _nftCollectionWhitelist
        });

        battles.push(battle);

        require(_prices.length > 0, "No prices");

        for (uint256 i = 0; i < _prices.length; i++) {
            require(_prices[i].numEntries > 0, "numEntries is 0");

            PriceStructure memory p = PriceStructure({
                id: _prices[i].id,
                numEntries: _prices[i].numEntries,
                price: _prices[i].price
            });

            prices[battles.length - 1][i] = p;
        }

        emit BattleStarted(battles.length - 1);

        return battles.length - 1;
    }

    /* * Example of a price structure:
    1 ticket 0.02
    5 tickets 0.018 (10% discount)
    10 tickets 0.16  (20% discount)
    25 tickets 0.35  (30% discount) 
    50 tickets 0.6 (40% discount)
*/
    /// @param _battleId battleId
    /// @param _priceId Id of the price structure
    /// @return the price structure of that particular Id + battle
    /// @dev Returns the price structure, used in the frontend
    function getPriceStructForId(uint256 _battleId, uint256 _priceId) internal view returns (PriceStructure memory) {
        for (uint256 i = 0; i < 5; i++) {
            if (prices[_battleId][i].id == _priceId) {
                return prices[_battleId][i];
            }
        }
        return PriceStructure({id: 0, numEntries: 0, price: 0});
    }


    function getPrice(uint256 _battleId, uint256 _priceId) internal view returns (uint256) {
        for (uint256 i = 0; i < 5; i++) {
            if (prices[_battleId][i].id == _priceId) {
                return prices[_battleId][i].price;
            }
        }
        return 0;
    }

    /// @dev this is the method that will be called by the smart contract to get a random number
    /// @param _id Id of the battle
    /// @param _entriesSize length of the entries array of that battle
    /// @return requestId Id generated by chainlink
    function getRandomNumber(uint256 _id, uint256 _entriesSize) internal returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        bytes32 result = requestRandomness(keyHash, fee);
        // result is the requestId generated by chainlink. It is saved in a map linked to the param id
        chainlinkBattleInfo[result] = BattleInfo({id: _id, size: _entriesSize});
        return result;
    }

    /// @dev Callback function used by VRF Coordinator. Is called by chainlink
    /// the random number generated is normalized to the size of the entries array, and an event is
    /// generated, that will be listened by the platform backend to be checked if corresponds to a
    /// member of the MW community, and if true will call transferPrize
    /// @param requestId id generated previously (on method getRandomNumber by chainlink)
    /// @param randomness random number (huge) generated by chainlink
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        BattleInfo memory battleInfo = chainlinkBattleInfo[requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = (randomness % battleInfo.size) + 1;

        // send the event with the original id and the random number
        emit RandomNumberCreated(battleInfo.id, randomness, normalizedRandomNumber);

        transferPrize(battleInfo.id, normalizedRandomNumber);
    }

    // helper method to get the winner address of a battle
    /// @param _battleId Id of the battle
    /// @param _normalizedRandomNumber Generated by chainlink
    /// @return the wallet that won the battle
    /// @dev Uses a binary search on the sorted array to retreive the winner
    /// but if the winner candidate is blacklisted, loop through the left looking for
    /// a candidate not blacklisted
    function getWinnerAddressFromRandom(
        uint256 _battleId,
        uint256 _normalizedRandomNumber
    ) public view returns (address) {
        uint256 position = findUpperBound(entriesList[_battleId], _normalizedRandomNumber);

        address candidate = entriesList[_battleId][position].player;
        // general case
        if (candidate != address(0)) return candidate;
        // special case. The user is blacklisted, so try next on the left until find a non-blacklisted
        else {
            bool ended = false;
            uint256 i = position;
            while (ended == false && entriesList[_battleId][i].player == address(0)) {
                if (i == 0) i = entriesList[_battleId].length - 1;
                else i = i - 1;
                // we came to the beginning without finding a non blacklisted player
                if (i == position) ended == true;
            }
            require(!ended, "All users blacklisted");
            return entriesList[_battleId][i].player;
        }
    }

    /// @param array sorted array of EntriesBought. CurrentEntriesLength is the numeric field used to sort
    /// @param element uint256 to find. Goes from 1 to entriesLength
    /// @dev based on openzeppelin code (v4.0), modified to use an array of EntriesBought
    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.
    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
    /// array is expected to be sorted in ascending order, and to contain no repeated elements.
    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
    function findUpperBound(EntriesBought[] storage array, uint256 element) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    // The operator can call this method once they receive the event "RandomNumberCreated"
    // triggered by the VRF v1 consumer contract (RandomNumber.sol)
    /// @param _battleId Id of the battle
    /// @param _normalizedRandomNumber index of the array that contains the winner of the battle. Generated by chainlink
    /// @notice it is the method that sets the winner and transfers funds
    /// @dev called by Chainlink callback
    function transferPrize(uint256 _battleId, uint256 _normalizedRandomNumber) internal nonReentrant {
        BattleStruct storage battle = battles[_battleId];
        // Only when the battle has been asked to be closed and the platform
        require(battle.status == Status.Close, "Battle in wrong status");

        battle.randomNumber = _normalizedRandomNumber;
        battle.winner = getWinnerAddressFromRandom(_battleId, _normalizedRandomNumber);

        uint256 treasuryFee = (battle.amountCollected * battle.treasuryFee) / 10000;

        uint256 weeklyJackpotBattle = (battle.amountCollected * battle.weeklyJackpotBattle) / 10000;

        uint256 _stakersReward = (battle.amountCollected * stakersReward) / 10000;

        uint256 winnerPrize = (battle.amountCollected - (treasuryFee + weeklyJackpotBattle + _stakersReward));

        // * Stakers
        (bool sent, ) = stakersAddress.call{value: _stakersReward}("");
        require(sent, "Failed to send Ether");

        // * Platform + Weekly jackpot
        (bool sent2, ) = treasuryWallet.call{value: (treasuryFee + weeklyJackpotBattle)}("");
        require(sent2, "Failed send Eth to MW");

        (bool sentPrize, ) = battle.winner.call{value: winnerPrize}("");
        require(sentPrize, "Failed to send Prize Ether");

        emit PrizeTransferred(_battleId, treasuryFee, weeklyJackpotBattle, _stakersReward, winnerPrize);
    }

    /// @param _battleId Id of the battle
    /// @notice the operator finish the battle, if the desired funds has been reached
    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player
    function endBattle(uint256 _battleId) external nonReentrant onlyOperator {
        BattleStruct storage battle = battles[_battleId];
        // Check if the battle is already accepted or is called again because early cashout failed
        require(battle.status == Status.Open, "Battle in wrong status");
        battle.status = Status.Close;

        // this call trigers the VRF v1 process from Chainlink
        getRandomNumber(_battleId, battle.entriesLength);

        emit BattleEnd(_battleId, battle.amountCollected);
    }

    /// @param _battleId Id of the battle
    /// @dev The operator can cancel the battle. The ETH is sent back to the seller
    /// The raised funds are send to the destination wallet. The buyers will
    /// be refunded offchain in the metawin wallet
    function cancelBattle(uint256 _battleId) external nonReentrant onlyOperator {
        BattleStruct storage battle = battles[_battleId];

        // Dont cancel twice, or cancel an already ended battle
        require(battle.status != Status.Close && battle.status != Status.Cancelled, "Wrong status");

        battle.status = Status.Cancelled;
        battle.cancellingDate = block.timestamp;

        emit BattleCancelled(_battleId, battle.amountCollected);
    }

    /// @dev for different reasons player entries should be void
    /// this has a cost in gas, but this makes cheaper in gas the callback from chainlink
    /// This method has to be called for every battle of the blacklisted player
    /// @param _battleId Id of the battle
    /// @param entriesToCancel array that contains the index of the entries to cancel. 0 based
    /// @param _player player who owns the entry to be voided
    function cancelEntry(uint256 _battleId, uint256[] calldata entriesToCancel, address _player) external onlyOperator {
        uint256 totalEntriesBoughtCancelled = 0;
        for (uint256 i = 0; i < entriesToCancel.length; i++) {
            EntriesBought storage entry = entriesList[_battleId][entriesToCancel[i]];

            require(entry.player == _player, "Entry did not belong to player");

            entry.player = address(0);

            uint256 previousTotalEntriesLength;
            if (entriesToCancel[i] == 0) previousTotalEntriesLength = 0;
            else previousTotalEntriesLength = entriesList[_battleId][entriesToCancel[i] - 1].currentEntriesLength;
            totalEntriesBoughtCancelled += entry.currentEntriesLength - previousTotalEntriesLength;
        }
        emit EntryCancelled(_battleId, totalEntriesBoughtCancelled, _player);
    }

    /// @param _battleId Id of the battle
    /// @dev The player can claim a refund during the first 30 days after the battle was cancelled
    /// in the map "ClaimsData" it is saves how much the player spent on that battle, as they could
    /// have bought several entries
    function claimRefund(uint256 _battleId) external nonReentrant {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Cancelled, "wrong status");
        require(block.timestamp <= battle.cancellingDate + 30 days, "claim time expired");

        ClaimStruct storage claimData = claimsData[keccak256(abi.encode(msg.sender, _battleId))];

        require(claimData.claimed == false, "already refunded");

        battle.amountCollected = battle.amountCollected - claimData.amountSpentInWeis;

        claimData.claimed = true;
        (bool sent, ) = msg.sender.call{value: claimData.amountSpentInWeis}("");
        require(sent, "Fail send refund");

        emit Refund(_battleId, claimData.amountSpentInWeis, msg.sender);
    }

    /// @param _battleId Id of the battle
    /// @dev after 30 days after cancelling passes, the operator can transfer to
    /// treasuryWallet the remaining funds
    function transferRemainingFunds(uint256 _battleId) external nonReentrant onlyOperator {
        BattleStruct storage battle = battles[_battleId];
        require(battle.status == Status.Cancelled, "Wrong status");
        require(block.timestamp > battle.cancellingDate + 30 days, "claim too soon");

        battle.status = Status.Cancelled;

        (bool sent, ) = treasuryWallet.call{value: battle.amountCollected}("");
        require(sent, "Fail send Eth to TW");

        emit RemainingFundsTransferred(_battleId, battle.amountCollected);

        battle.amountCollected = 0;
    }

    function injectFunds(uint256 _battleId) external payable onlyOwnerOrInjector {
        require(msg.value > 0, "Eth not sent");
        require(battles[_battleId].status == Status.Open, "Battle not open");

        battles[_battleId].amountCollected += msg.value;

        emit BattleInjection(_battleId, msg.value);
    }

    /// @param _newAddress new address of the platform
    /// @dev Change the wallet of the platform. The one that will receive the platform fee when the battle is closed.
    /// Only the admin can change this
    function setTreasuryAddress(address payable _newAddress) external onlyOwner {
        require(_newAddress != address(0), "Cannot be zero address");
        treasuryWallet = _newAddress;
    }

    function setOperatorAddress(address _operatorAddress) external onlyOwner {
        require(_operatorAddress != address(0), "Cannot be zero address");
        operatorAddress = _operatorAddress;
    }

    function setInjectorAddress(address _injectorAddress) external onlyOwner {
        require(_injectorAddress != address(0), "Cannot be zero address");
        injectorAddress = _injectorAddress;
    }

    function setStakersAddress(address payable _newAddress) external onlyOwner {
        require(_newAddress != address(0), "Address invalid");
        stakersAddress = _newAddress;
    }

    function changeStakersReward(uint256 _stakersRewardInBps) external onlyOwner {
        stakersReward = stakersReward;
        emit StakersRewardChanged(_stakersRewardInBps);
    }

    /// @param _battleId Id of the battle
    /// @return array of entries bougth of that particular battle
    function getEntriesBought(uint256 _battleId) external view returns (EntriesBought[] memory) {
        return entriesList[_battleId];
    }

    /// @param _battleId Id of the battle
    /// @param _player wallet of the player
    /// @return Claims data of the player on that battle
    function getClaimData(uint256 _battleId, address _player) external view returns (ClaimStruct memory) {
        return claimsData[keccak256(abi.encode(_player, _battleId))];
    }

    function playerIsBlacklisted(address _player) external view returns (bool) {
        return blackListManager.isBlackListed(_player);
    }

    function battleNotInOpenState(uint256 _battleId) external view returns (bool) {
        BattleStruct memory battle = battles[_battleId];
        return (battle.status != Status.Open);
    }

    function playerReachedMaxEntries(
        address _player,
        uint256 _battleId,
        uint256 _amountOfEntries
    ) external view returns (bool) {
        BattleStruct memory battle = battles[_battleId];

        if(battle.maxEntries == 0) {
            return false;
        }

        bytes32 hash = keccak256(abi.encode(_player, _battleId));
        // check there are enough entries left for this particular user
        return (claimsData[hash].numEntriesPerUser + _amountOfEntries > battle.maxEntries);
    }

    function getBattle(uint _battleId) external view returns (BattleStruct memory battle) {
        battle = battles[_battleId];
    }

    /* 
    @param _player The address of the player    
    @param _battleId id of the battle
    @param _colection Address of the required collection, if any
    @param _tokenIdUsed Id of the token of the required collection the player says he has and want to use in the battle
    @returns bool if the player can buy or not, and string with the cause of the rejection. "" if can buy
    @notice Method that returns if the user can or cannot buy entries because the player owns an nft in the case or required collections.
    */
    function playerHasRequiredNFTs(
        address _player,
        uint256 _battleId,
        address _collection,
        uint256 _tokenIdUsed
    ) external view returns (bool canBuy, string memory cause) {
        BattleStruct memory battle = battles[_battleId];

        // if the battle requires an nft
        if (battle.nftCollectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i = 0; i < battle.nftCollectionWhitelist.length; i++) {
                if (battle.nftCollectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            if (hasRequiredCollection == false) return (false, "Not in required collection");

            IERC721 requiredNFT = IERC721(_collection);
            if (requiredNFT.ownerOf(_tokenIdUsed) != _player) return (false, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(abi.encode(_collection, _battleId, _tokenIdUsed));
            // check the tokenId has not been using yet in the battle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] != _player) return (false, "tokenId used");
        }

        return (true, "");
    }

    /**
     * @notice Check if an address is a contract
     */
    function _isContract(address _addr) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }
}
